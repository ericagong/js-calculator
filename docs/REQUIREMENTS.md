# 🧮 계산기 미션

피연산자 2개와 연산자 1개를 입력으로 받아, 사칙연산 결과를 콘솔에 출력하는 코드 구현하기.

## 🎯 미션 요구사항

:.: 2개의 숫자에 대해 덧셈이 가능하다.

:.: 2개의 숫자에 대해 뺄셈이 가능하다.

:.: 2개의 숫자에 대해 곱셈이 가능하다.

:.: 2개의 숫자에 대해 나눗셈이 가능하다.

:.: 숫자는 한번에 최대 3자리 수까지만 다룰 수 있다.

:.: 계산 결과를 표현할 때 소수점 이하는 버림한다.

# 🔄 TDD Cycle을 따라 계산기 미션 수행하기

## ✏️ 요구 사항을 기능 단위로 구분하기

### 📌 Feature 1. 피연산자 유효성 확인하기(Domain)

:V: 피연산자가 빈 값인지 체크해 오류 발생

:V: 피연산자가 숫자나 문자열 형태의 숫자가 아닌지 체크해 오류 발생

:V: 피연산자가 세 자리 초과인지 체크해 오류 발생

:.: 각 단계에서 오류 발생 시 공통된 처리 패턴으로 처리

### 📌 Feature 2. 연산 결과 반환하기(Domain)

:V: 피연산자 두 개에 대한 사칙연산 결과 반환하기

:V: 단, `/` 연산자 특수처리

-   첫 번째 피연산자만 0인 경우, 0
-   두 번째 피연산자만 0인 경우, `+-Infinity`
-   두 피연산자 모두 0일 경우, `NaN`

### 📌 Feature 3. 연산 결과 특수 처리(Domain)

:V: Feature 2의 연산 결과를 입력으로 받아, 오류가 있는 경우 `오류` 반환

:V: 오류가 없는 경우, 소수점 이하는 버림 처리하고 반환

-   양수인 경우, 소수점 버림
-   음수인 경우, 소수점 올림

:V: `-0`이 연산 결과인 경우, 모두 `0` 반환

-   소수점 버림 처리한 결과 값이 -0일 때도 0으로 처리

### 📌 Feature 4. 연산 결과 콘솔 출력(UI)

:.: 연산 결과값 콘솔에 출력

## 🔢 기능 구현 순서 정하기

-   우선 Domain 로직 구현 -> UI 로직 구현

### 📌 기준

✅ 해당 기능을 먼저 구현할 때, 이후 기능 구현이 편해지는가?
✅ 해당 기능을 먼저 구현할 때, 핵심 기능 구현에 더 가까워지는가?

### 📌 구현 순서 선정

-   Domain 로직 : Feature 2 -> Feature 3 -> Feature 1
-   UI 로직 : Feature 4

### 📌 리팩토링 고려 사항

-   중복 제거: `모듈화`가 필요한 부분을 처리한다.
-   가독성:
    -   `의도가 잘 드러나는` 코드인지 점검한다.
    -   `목적에 맞는` 메소드/함수를 사용해서 기능을 구현하였는지 점검한다.
-   확장성:
    -   향후 `요구사항 변경이 가능한 지점`을 체크하여, 외부로 뽑아낸다.
