## 📄 3분 요약

안녕하세요. 멘토님, 만나뵙게되어 반갑습니다. 가감없는 피드백 부탁드립니다. 많이 배워가겠습니다 🥊

-   전체적인 개괄을 정리하고 싶어서 크게 `목표`, `기능분리`, `고민했던 지점 및 질문` 으로 정리했습니다.
-   정리하다보니 내용이 길어져서요, `목표`, `기능 분리` 는 중요치 않으니 `고민했던 지점 및 질문 부분`만 읽고 피드백 주셔도 충분할 것 같습니다.
-   코드 리뷰 시, 아래 사항들을 한 번 체크해 주시면 좋겠습니다.

    **[피드백 고려 사항]**

    ✅ 에러 객체 추상 클래스 - 구현 클래스 구조 및 에러 처리 방식이 올바른지

    ✅ 클래스로 구현했을 때와 함수화 했을 때의 장단점 비교

    ✅ 외부모듈 의존성을 가진 테스트 코드가 올바르게 작성되었는지

    ✅ 함수가 하나의 책임을 가질 수 있게 모듈 분리가 잘 이루어졌는지

    ✅ 함수나 상수 이름이 이해되지 않는 부분은 없는지

## 🎯 목표

1. [직접 정의한 나만의 TDD 7단계 사이클](https://github.com/ericagong/js-calculator/blob/TDD/docs/TDD_CYCLE.md)을 따라 미션을 진행하되, 문제점이 있다면 사이클을 변경한다.
2. 요구 사항을 분석하여 `핵심을 포함한 동작가능한 가장 작은 버전`을 빠르게 구현한 뒤, 이를 확장한다.
3. `(1) 재사용성 (2) 가독성 (3) 성능` 측면에서 클린코드를 지향하며 코드를 리팩토링 한다.
4. 개발 환경을 구축한다. (ESLint, Prettier, CommitLint, Husky)

## 👷🏻 기능 분리

-   구현 결과에 대한 문장을 아래와 같이 정의하였습니다.
    -   `두 개의 피연산자와 하나의 연산자를 입력받아 사칙연산 결과를 출력한다`
-   요구 사항에 따라, 구현이 필요한 기능을 크게 네 가지로 나누었습니다.

    **📌 [Feature1] 피연산자 유효성 검사**

    -   두 개의 피연산자가 `빈 값` / `숫자로 변환 불가한 데이터 값` / `정수부 세 자릿 수 초과` 시 오류 생성하도록 처리

    **📌 [Feature2] 사칙연산 결과 반환**

    -   피연산자 2개와 연산자를 `operate` 함수에 제공해 사칙연산 수행

    **📌 [Feature3] 사칙연산 결과 유효성 검사**

    -   사칙연산 결과가 `NaN` 인 경우, 오류 생성하도록 처리

    **📌 [Feature4] 사칙연산 결과 조정**

    -   사칙연산 결과에 대해 소수점 버림 처리 후 정수부만 반환
    -   사칙 연산 결과가 `-Infinity` / `Infinity`라면 오류 문자열 반환
    -   사칙연산 결과가 `-0` 인 경우 `0` 으로 변환

-   (1) 구현 편의성과 (2) 확장 편의성 두 기준에 따라 [Feature2] -> [Feature3] -> [Feature4] -> [Feature1] 순서로 구현하였습니다.

## 🤔 고민했던 지점 및 연관 질문

### ❓ ValidationError 추상 클래스 기반 에러 처리

**_[As-Is]_**

-   계산기 미션에서는 아래와 같이 총 4가지 종류의 에러가 발생하며, 이는 모두 `값의 유효성 검증`이라는 공통 속성을 가지고 있습니다.

    (1) 피연산자 : 3자리 수 초과, 숫자나 숫자로 된 문자열이 아닌 타입, 빈 값.

    (2) 연산자 : +, -, \*, / 외의 타입

    (3) 연산 결과: NaN

-   이를 에러 발생 지점과 처리 방법이라는 기준에 따라 나눠보면 아래와 같이 크게 두 타입으로 나눌 수 있으므로, `ValidationError` 추상 클래스를 도입하였습니다. 실제 `InputValidationError`와 `OutputValidationError` 구현 클래스에서는 다형성 덕분에 내부의 `handle()` 에러 처리 로직을 유연하게 설정할 수 있습니다.

| 에러 종류             | 발생 지점               | 에러 처리 방법                    | 에러 메시지                                                                    |
| --------------------- | ----------------------- | --------------------------------- | ------------------------------------------------------------------------------ |
| InputValidationError  | 사용자 입력 유효성 검사 | 사용자 재입력 요청 또는 콘솔 경고 | Operand: 길이 에러, 타입 에러, 빈 값 에러<br>Operator: 유효하지 않은 타입 에러 |
| OutputValidationError | 연산 결과 유효성 검사   | 콘솔 에러 메시지 출력             | NaN 결과 에러                                                                  |

-   오류 처리 지점은 최상단인 `Calculater.calculate(operator, operand1, operand2)` 내의 try-catch문으로 통일되어있습니다.

**_[Question]_**

(1) `상기 오류 처리 흐름과 구조가 자연스러운지` 의문이 듭니다. 보다 자연스러운 설계 방식이 있다면, 공유해주시면 좋겠습니다.

(2) js에서 `추상 클래스`를 지원하지 않아 함수가 구현되지 않았을 때, 에러를 발생시키는 형식으로 구현했습니다. 피드백 부탁드립니다.

### ❓메소드 및 모듈 분리 방식

**_[As-Is]_**

-   `Calculator` 클래스의 공용 인터페이스인 calculate을 제외한 모든 로직을 (1) validation (2) operation (3) normalize로 나누어 각각 모듈화했습니다.

**_[Question]_**

-   `모듈이 너무 작은 단위로 쪼갠 것은 아닌지` 피드백 부탁드립니다.
-   `함수가 최대한 하나의 책임만 수행하도록 처리`하고자 했습니다. 점검 부탁드립니다.

### ❓클래스 vs 함수

**_[As-Is]_**

-   현재 코드에서는 `Calculator`는 클래스로 그 외 유효성 검사, 연산, 결과값 조정 로직은 각각 `validation`, `operation`, `normalize` 파일 내의 함수로 구현하였습니다.

**_[Question]_**

(1) 코드 작성 이후, 굳이 `왜 Calculator를 클래스로 구현했을까?` 하는 의문이 들었습니다. 클래스 선언은 이후 인스턴스를 사용할 것이라는 의미를 내포하고 있다고 생각하는데, 미션에서는 계산기를 굳이 인스턴스로 관리해야 할 필요가 없다고 느꼈기 때문입니다. - 계산기 미션에서는 (1) 인스턴스 별로 관리해야할 데이터도 없을 뿐더러, (2) prototype 연결로 인한 장점도 없다고 생각됩니다. - 물론 기능 단위로 모듈화하거나 파일을 분리하는 것은 좋지만, 클래스 선언까지는 overspec이 아닌가 하는 생각이 듭니다. - `이 부분`에 대해서 어떻게 생각하시나요? `실무에서 class로 선언하기로 판단하게 되는 기준은 무엇인지` 알려주시면 향후 코드 작성에 큰 도움이 될 것 같습니다.

(2) 그 외에 `validation, operation, normalize`를 함수로 구현하지 않고, 클래스로 구현하여 `Calculator`의 외부에서 주입하는 구현 방법의 장점도 고민해보았습니다.

-   클래스로 작성해서 외부 주입하는 경우, 의존성이 낮아집니다. 예를 들어, 사칙 연산만 제공하는 계산기 외에도 나눗셈 연산까지 제공하는 계산기가 필요한 경우나 결과값을 조정할 때 정수부만 보여주는 계산기 외에 소수점 3자리에서 반올림하는 계산기를 만드는 등 요구 사항이 변경되더라도 기존 기능을 확장하여 간단히 구현할 수 있습니다.
-   그렇다면 함수로 구현하는 경우에 비해 단점은 무엇이 있을까요? 고민해 보았지만 가독성 저해, 개발 비용 증가 외의 단점이 떠오르지 않습니다. 멘토님과 이 주제에 대해 의견 나눠보고 싶습니다.
